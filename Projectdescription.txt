Project Description: Part 1 - A Simple Unix Shell (Back to Beginning)
Design and implement with C programming language a simple UNIX shell program satisfying the requirements specified below. Please allow for at least 100 commands in a command line and at least 1000 arguments in each command.

In addition to the above, the following are required:

Reconfigurable shell prompt (default %)

The shell must have a shell built-in command prompt for changing the current prompt. For example, type the following command

% prompt john$
should change the shell prompt to john$, i.e., the second token of the command.

The shell built-in command pwd

This command prints the current directory (also known as working directory) of the shell process.

Directory walk

This command is similar to that provided by the Bash built-in command cd. In particular, typing the command without a path should set the current directory of the shell to the home directory of the user.

Wildcard characters

If a token contains wildcard characters * or ?, the token is treated as a filename. The wildcard characters in such a token indicate to the shell that the filename must be expanded. For example the command

% ls *.c
may be expanded to ls ex1.c ex2.c ex3.c if there are three matching files ex1.c ex2.c ex3.c in the current directory.

You may implement this feature using the C function glob.

Redirection of the standard input, standard output and standard error <, > and 2>

For example:

% ls -lt >  foo
would redirect the standard output of the process ls -lt to file foo. Similarly, in the following command,

% cat <  foo
the standard input of the process cat is redirected to file foo. The following command tries to list the files in a non-existent directory xxxx. The error message would be saved to file error.

% ls /xxxx 2>  error
the standard error of the process ls is redirected to file error.

Shell pipeline |

For example:

% ls -lt | more
the standard output of the process ls -lt is connected to the standard input of the process more via a pipe.

Background job execution

For example:

% xterm &
The commannd line starts the command xterm in the background (i.e., the shell will not wait for the process to terminate and you can type in the next command immediately while xterm is still running). The following command line

% sleep 20 &  ps -l
starts the command sleep 20 and immediately execute the command ps -l without waiting for the command sleep 20 to finish first.

Sequential job execution

For example the command line

%  sleep 20 ; ps -l
starts the command sleep 20 first, and wait for it to finish, then execute the command ps -l.

Command history

The shell remembers the commands entered into the shell and the user can select one of the previous commands by the Up Arrow key and Down Arrow key. You may use ncurses library to monitor the arrow keys.

The user can also display the past commands using shell builtin command history.

Furthermore, the user can repeat the last command by typing !! and repeat a previous command using the special character ! followed by the command number, eg, !12, which would repeat the 12th command. The shell can also repeat the last command that starts with a string using !string.

The shell environment

The shell should inherit its environment from its parent process.

The shell built-in command exit

Use the built-in command exit to terminate the shell program.

The behaviour of the above shell builtin commands (except prompt) should be as close to those of the Bash shell as possible. In addition, your shell should not be terminated by CTRL-C, CTRL-\, or CTRL-Z.

Finally, you must not use any existing shell program to implement your shell (for example by calling a shell through the function system). That would defeat the purpose of this project.

In the above, the commands such as ls, cat, grep, sleep, ps and xterm are used as examples to illustrate the use of your shell program. However, your shell must be able to handle any command or executable program. Note the commands prompt, pwd, cd, history and exit should be implemented as shell builtins, not as external commands.

The syntax and behaviour of the built-in commands pwd, cd and exit should be similar to the corresponding commands under Bash shell.

A major part of this project is a command line parser. Please read the this note for suggestions on implementing the parser.

Definition of Command Line Syntax
The following is the formal definition of the command line syntax for the shell, defined in Extended BNF:

   < command line >      ::=   < job >
                             | < job > '&'
                             | < job > '&' < command line >
                             | < job > ';'
                             | < job > ';' < command line >
                             | '!'< string >

   < job >               ::=   < command >
                             | < job > '|' < command >

   < command >           ::=   < simple command >
                             | < simple command > '<' < pathname >
                             | < simple command > '>' < pathname >
                             | < simple command > '2>' < pathname >

   < simple command >    ::=   < pathname >
                             | < simple command >  < token >
An informal definition plus additional explanations of the syntax is given below:

A command line consists of one or several jobs separated by the special character "&" and/or ";". The last job may be followed by the character "&" or ";". If a job is followed by the character "&", then it should be executed in the background.

A job consists of one or more commands separated by pipeline characters "|";

A command is either a simple command or a simple command followed by an input redirection (< pathname) or an output redirection (> pathname) or an error redirection (2> pathname);

A simple command consists of a single pathname followed by zero or more tokens;

The following eight characters are the special characters to the shell: ', ", &, ;, |, < , > and !;

The white space characters are defined to be the space character and the tab character;

A token is a string. A string is a sequence of characters that does not normally contain space characters or special characters. If a string contains a space character or a special character, it must be preceded by the back slash character "\". In such a case, the back slash character and the space character, or the back slash character and the special character are intepreted as a single normal character without the special meaning. For example, the two character \& is interpreted as the normal character &.

A token can also be a quoted string, either using single quotes character ' or double quote character ". A single quoted string cannot contain the single quote character ' unless it is proceeded by a back slash, in which case, the back slash and the single quote together are taken as a normal single quote character without special meaning. This is similar for the double quoted strings. Other special characters appear in a quoted string are considered as normal characters with no special meaning.

Tokens must be separated by one or more white spaces;

A pathname is either a file name, or an absolute pathname, or a relative pathname. Examples of pathnames are grep, /usr/bin/grep, bin/grep and ./grep;

A command line must end with a newline character.